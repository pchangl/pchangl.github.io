<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>那些有趣的算法之布隆过滤器 | sizeofio</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="布隆过滤器是由Burton Bloom与1970年提出来的，所以它的名字就叫做Bloom Filter。它实际上是一个很长的二进制向量和一系列的随机映射函数。 使用场景 有的黑客为了让服务宕机，他们会构建大量不存在于缓存中的key向服务器发起请求，在数据量足够大的情况下，频繁的数据库查询可能导致DB挂掉。布隆过滤器很好的解决了缓存击穿的问题。 反垃圾邮件，从数十亿个垃圾邮件列表中判断某个邮箱是否是">
<meta property="og:type" content="article">
<meta property="og:title" content="那些有趣的算法之布隆过滤器">
<meta property="og:url" content="http://sizeof.io/2019/02/28/那些有趣的算法之布隆过滤器/index.html">
<meta property="og:site_name" content="sizeofio">
<meta property="og:description" content="布隆过滤器是由Burton Bloom与1970年提出来的，所以它的名字就叫做Bloom Filter。它实际上是一个很长的二进制向量和一系列的随机映射函数。 使用场景 有的黑客为了让服务宕机，他们会构建大量不存在于缓存中的key向服务器发起请求，在数据量足够大的情况下，频繁的数据库查询可能导致DB挂掉。布隆过滤器很好的解决了缓存击穿的问题。 反垃圾邮件，从数十亿个垃圾邮件列表中判断某个邮箱是否是">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/2/27/1692ac8d9eff3949?w=649&h=233&f=png&s=22519">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/2/27/1692ac8d9eea2731?w=160&h=59&f=png&s=3689">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/2/27/1692ac8d9f0108a6?w=410&h=222&f=png&s=41126">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/2/27/1692ac8d9f1fb164?w=339&h=62&f=jpeg&s=5818">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/2/27/1692ac8d9f15d51b?w=209&h=65&f=png&s=5825">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/2/27/1692ac8d9f21b88c?w=280&h=48&f=png&s=5641">
<meta property="og:updated_time" content="2019-02-28T07:43:12.023Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="那些有趣的算法之布隆过滤器">
<meta name="twitter:description" content="布隆过滤器是由Burton Bloom与1970年提出来的，所以它的名字就叫做Bloom Filter。它实际上是一个很长的二进制向量和一系列的随机映射函数。 使用场景 有的黑客为了让服务宕机，他们会构建大量不存在于缓存中的key向服务器发起请求，在数据量足够大的情况下，频繁的数据库查询可能导致DB挂掉。布隆过滤器很好的解决了缓存击穿的问题。 反垃圾邮件，从数十亿个垃圾邮件列表中判断某个邮箱是否是">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2019/2/27/1692ac8d9eff3949?w=649&h=233&f=png&s=22519">
  
  <link rel="stylesheet" href="/css/index.css">
</head>
</html>
<body style="


  background-color: #eff0f6

">
  <div id="container">
    <nav id="nav">
  <header class="header">
    <a href="/" class="title">SIZEOF IO</a>
  </header>
  <div class="ctnWrap">
    <div class="icons">
      
        
          
            <a href="https://github.com/pchangl" target="_blank" class="nav-icn iconfont icon-github"></a>
          
        
      
    </div>
    <div class="menu">
      
        
            <a href="/" class="nav-menu ">HOME</a>
          
        
            <a href="/archives" class="nav-menu ">ARCHIVE</a>
          
        
            <a href="/about" class="nav-menu ">ABOUT</a>
          
        
      
    </div>
  </div>
</nav>
    <div id="main"><section class="article">
  <h2 class="title">那些有趣的算法之布隆过滤器</h2>
  <p class="sub">Feb 28, 2019</p>
  <article class="content">
    <p>布隆过滤器是由Burton Bloom与1970年提出来的，所以它的名字就叫做Bloom Filter。它实际上是一个很长的二进制向量和一系列的随机映射函数。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>有的黑客为了让服务宕机，他们会构建大量不存在于缓存中的key向服务器发起请求，在数据量足够大的情况下，频繁的数据库查询可能导致DB挂掉。布隆过滤器很好的解决了缓存击穿的问题。</li>
<li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某个邮箱是否是垃圾邮箱。</li>
<li>网页爬虫对URL去重，防治爬取相同的URL地址</li>
<li>…</li>
</ol>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>一个空的布隆过滤器是由m个bits组成的bit array，每一个bit位都初始为0。并且定义有k个不同的哈希函数，每个哈希函数都将元素哈希到bit array的不同位置。</p>
<p>当添加一个元素时，用k个哈希函数分别将它hash得到k个bit位，然后将这些bit位置位1。</p>
<p>查询一个函数时，同样用k个哈希函数将它hash，再判断k个bit位上是否都为1，如果其中某一位为0，则该元素不存在于布隆过滤器中。</p>
<p>常规的布隆过滤器不允许执行删除元素操作，因为那样会把k个bits位置位0，而其中某一位可能和其他元素想对应。因此删除操作会引入false negative，如果需要删除操作可以使用<code>Counting Bloom Filter</code></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/27/1692ac8d9eff3949?w=649&amp;h=233&amp;f=png&amp;s=22519" alt="enter image description here"></p>
<p>当k很大时，设计k个独立的哈希函数是不现实的。对于一个输出范围很大的哈希函数（MD5产生的128 bits），如果不同bits的相关性很小，则可以把此输出分割位k份。或者将k个不同的初始值结合元素，feed给一个哈希函数从而产生k个不同的值。</p>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>就以垃圾邮件过滤为例，假定我们有一亿个垃圾邮件地址，每个邮件用8个hash函数来生成8个信息指纹，因为在保证误判率低且k和m选取合适时，空间利用率为50%。所以我们的m(布隆过滤器的槽数)为<img src="https://user-gold-cdn.xitu.io/2019/2/27/1692ac8d9eea2731?w=160&amp;h=59&amp;f=png&amp;s=3689" alt="enter image description here">，也就是16亿个二进制位。我们先将所有二进制位全部清零。对于每个邮件地址X，我们用8个不同的hash函数进行hash，再将这8个信息指纹映射到1-16亿中的8个自然数g1,g2,…g8。现在将这8个位置的二进制值全部置为1。对一亿个邮件地址都进行这样的处理后，我们的布隆过滤器也就建成功了。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/27/1692ac8d9f0108a6?w=410&amp;h=222&amp;f=png&amp;s=41126" alt="enter image description here"></p>
<p>当我们要判断一个邮件地址是否在布隆过滤器中时，需要使用相同的8个hash函数来将8个信息指纹对应到布隆过滤器的8个二进制位上。如果8个二进制位的值只要有一个或更多为0，那么它一定不存在于布隆中。如果8个值全都为1，那么它可能存在于布隆中，这是因为误识别导致的。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>相对于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数。另外，hash函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储数据本身，在某些对保密要求非常严格的场合由优势。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>布隆过滤器的缺点和其优点一样明显。误算率(False Positive)是其中之一。随着存入元素的数量增加，误算率随之增加。</p>
<h3 id="误判概率的证明和计算"><a href="#误判概率的证明和计算" class="headerlink" title="误判概率的证明和计算"></a>误判概率的证明和计算</h3><p>在上面的案例中，我们说到过关于布隆的误算率的问题，这在检验上被称为<code>假阳性</code>。</p>
<p>估算假阳性的概率并不难。假定布隆过滤器有<code>m</code>比特，里面有<code>n</code>个元素，每个元素对应<code>k</code>个信息指纹的哈希函数，当然这里<code>m</code>比特里有些是0有些是1。我们先来看看某个比特为0的概率。当我们在插入一个元素时，它的第一个哈希函数会把过滤器中的某个比特置为1，因此，任何一个比特被置为1的概率是<code>1/m</code>，它依然为0的概率则为<code>1-1/m</code>。对于过滤器中的某个特定位置，如果这个元素k个哈希函数都没有把它设置为1，其概率是<code>(1-1/m)^k</code>。如果过滤器插入第二个元素，某个特定位置依然没有被设置为1，其概率为<code>(1-1/m)^2k</code>。如果插入了n个元素，还是没有把某个位置设置为1，其概率为<code>(1-1/m)^kn</code>。反过来，一个比特在插入了n个元素后，被置为1的概率为<code>1-(1-1/m)^kn</code>。</p>
<p>现在假定这n个元素都放到了过滤器中，新来一个不在集合中的元素，由于它的信息指纹的哈希函数都是随机的，因此，它的第一个哈希函数正好命中某个值为1的比特的概率就是上述概率。一个不在集合中的元素被误识别为在集合中，所需要的哈希函数对应比特的值均为1，其概率为:</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/27/1692ac8d9f1fb164?w=339&amp;h=62&amp;f=jpeg&amp;s=5818" alt="enter image description here"></p>
<p>化简后为：<br><img src="https://user-gold-cdn.xitu.io/2019/2/27/1692ac8d9f15d51b?w=209&amp;h=65&amp;f=png&amp;s=5825" alt="enter image description here"></p>
<p>如果n比较大，可以近似为：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/27/1692ac8d9f21b88c?w=280&amp;h=48&amp;f=png&amp;s=5641" alt="enter image description here"></p>
<h3 id="PHP实现"><a href="#PHP实现" class="headerlink" title="PHP实现"></a>PHP实现</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BloomFilterHash</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由Justin Sobel 编写的按位散列函数.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> null $len</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">JSHash</span><span class="params">($string, $len = null)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $hash = <span class="number">1315423911</span>;</span><br><span class="line">        $len || $len = strlen($string);</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $len; $i ++) &#123;</span><br><span class="line">            $hash ^= (($hash &lt;&lt; <span class="number">5</span>) + ord($string[$i]) + ($hash &gt;&gt; <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ($hash % <span class="number">0xFFFFFFFF</span>) &amp; <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该哈希算法基于AT＆T贝尔实验室的Peter J. Weinberger的工作。</span></span><br><span class="line"><span class="comment">     * Aho Sethi和Ulman编写的“编译器（原理，技术和工具）”一书建议使用采用此特定算法中的散列方法的散列函数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> null $len</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">PJWHash</span><span class="params">($string, $len = null)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $bitsInUnsignedInt = <span class="number">4</span> * <span class="number">8</span>;</span><br><span class="line">        $threeQuarters = ($bitsInUnsignedInt * <span class="number">3</span>) / <span class="number">4</span>;</span><br><span class="line">        $oneEighth = $bitsInUnsignedInt / <span class="number">8</span>;</span><br><span class="line">        $highBits = <span class="number">0xFFFFFFFF</span> &lt;&lt; (int) ($bitsInUnsignedInt - $oneEighth);</span><br><span class="line">        $hash = <span class="number">0</span>;</span><br><span class="line">        $test = <span class="number">0</span>;</span><br><span class="line">        $len || $len = strlen($string);</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $len; $i ++) &#123;</span><br><span class="line">            $hash = ($hash &lt;&lt; (int) ($oneEighth)) + ord($string[$i]);</span><br><span class="line">        &#125;</span><br><span class="line">        $test = $hash &amp; $highBits;</span><br><span class="line">        <span class="keyword">if</span> ($test != <span class="number">0</span>) &#123;</span><br><span class="line">            $hash = (($hash ^ ($test &gt;&gt; (int)($threeQuarters))) &amp; (~$highBits));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ($hash % <span class="number">0xFFFFFFFF</span>) &amp; <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类似PJW Hash功能，但是针对32位处理器做了调整。它是基于unix系统上的widely使用哈希函数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> null $len</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">ELEHash</span><span class="params">($string, $len = null)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $hash = <span class="number">0</span>;</span><br><span class="line">        $len || $len = strlen($string);</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $len; $i++) &#123;</span><br><span class="line">            $hash = ($hash &lt;&lt; <span class="number">4</span>) + ord($string[$i]);</span><br><span class="line">            $x = $hash &amp; <span class="number">0xF0000000</span>;</span><br><span class="line">            <span class="keyword">if</span> ($x != <span class="number">0</span>) &#123;</span><br><span class="line">                $hash ^= ($x &gt;&gt; <span class="number">24</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            $hash &amp;= ~$x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ($hash % <span class="number">0xFFFFFFFF</span>) &amp; <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个哈希函数来自Brian Kernighan和Dennis Ritchie的书“The C Programming Language”。</span></span><br><span class="line"><span class="comment">     * 它是一个简单的哈希函数，使用一组奇怪的可能种子，它们都构成了31 .... 31 ... 31等模式，它似乎与DJB哈希函数非常相似。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">BKDRHash</span><span class="params">($string, $len = null)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $seed = <span class="number">131</span>;  <span class="comment"># 31 131 1313 13131 131313 etc..</span></span><br><span class="line">        $hash = <span class="number">0</span>;</span><br><span class="line">        $len || $len = strlen($string);</span><br><span class="line">        <span class="keyword">for</span> ($i=<span class="number">0</span>; $i&lt;$len; $i++) &#123;</span><br><span class="line">            $hash = (int) (($hash * $seed) + ord($string[$i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ($hash % <span class="number">0xFFFFFFFF</span>) &amp; <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这是在开源SDBM项目中使用的首选算法。</span></span><br><span class="line"><span class="comment">     * 哈希函数似乎对许多不同的数据集具有良好的总体分布。它似乎适用于数据集中元素的MSB存在高差异的情况。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">SDBMHash</span><span class="params">($string, $len = null)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $hash = <span class="number">0</span>;</span><br><span class="line">        $len || $len = strlen($string);</span><br><span class="line">        <span class="keyword">for</span> ($i=<span class="number">0</span>; $i&lt;$len; $i++) &#123;</span><br><span class="line">            $hash = (int) (ord($string[$i]) + ($hash &lt;&lt; <span class="number">6</span>) + ($hash &lt;&lt; <span class="number">16</span>) - $hash);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ($hash % <span class="number">0xFFFFFFFF</span>) &amp; <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由Daniel J. Bernstein教授制作的算法，首先在usenet新闻组comp.lang.c上向世界展示。</span></span><br><span class="line"><span class="comment">     * 它是有史以来发布的最有效的哈希函数之一。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">DJBHash</span><span class="params">($string, $len = null)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $hash = <span class="number">5381</span>;</span><br><span class="line">        $len || $len = strlen($string);</span><br><span class="line">        <span class="keyword">for</span> ($i=<span class="number">0</span>; $i&lt;$len; $i++) &#123;</span><br><span class="line">            $hash = (int) (($hash &lt;&lt; <span class="number">5</span>) + $hash) + ord($string[$i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ($hash % <span class="number">0xFFFFFFFF</span>) &amp; <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Donald E. Knuth在“计算机编程艺术第3卷”中提出的算法，主题是排序和搜索第6.4章。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">DEKHash</span><span class="params">($string, $len = null)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $len || $len = strlen($string);</span><br><span class="line">        $hash = $len;</span><br><span class="line">        <span class="keyword">for</span> ($i=<span class="number">0</span>; $i&lt;$len; $i++) &#123;</span><br><span class="line">            $hash = (($hash &lt;&lt; <span class="number">5</span>) ^ ($hash &gt;&gt; <span class="number">27</span>)) ^ ord($string[$i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ($hash % <span class="number">0xFFFFFFFF</span>) &amp; <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参考 http://www.isthe.com/chongo/tech/comp/fnv/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">FNVHash</span><span class="params">($string, $len = null)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $prime = <span class="number">16777619</span>; <span class="comment">//32位的prime 2^24 + 2^8 + 0x93 = 16777619</span></span><br><span class="line">        $hash = <span class="number">2166136261</span>; <span class="comment">//32位的offset</span></span><br><span class="line">        $len || $len = strlen($string);</span><br><span class="line">        <span class="keyword">for</span> ($i=<span class="number">0</span>; $i&lt;$len; $i++) &#123;</span><br><span class="line">            $hash = (int) ($hash * $prime) % <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">            $hash ^= ord($string[$i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ($hash % <span class="number">0xFFFFFFFF</span>) &amp; <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilterRedis</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要使用一个方法来定义bucket名字.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $bucket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> $hashFunction;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">$this</span>-&gt;bucket || !<span class="keyword">$this</span>-&gt;hashFunction) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"需要定义bucket和hashFunction"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;Hash = <span class="keyword">new</span> BloomFilterHash;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;Redis = <span class="keyword">new</span> \Redis();   <span class="comment">// 假设已经连接好了</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;Redis-&gt;connect(<span class="string">'127.0.0.1'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">($string)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $pipe = <span class="keyword">$this</span>-&gt;Redis-&gt;multi();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;hashFunction <span class="keyword">as</span> $function) &#123;</span><br><span class="line">            $hash = <span class="keyword">$this</span>-&gt;Hash-&gt;$function($string);</span><br><span class="line">            $pipe-&gt;setBit(<span class="keyword">$this</span>-&gt;bucket, $hash, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $pipe-&gt;exec();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询是否存在，不存在的一定不存在，存在的可能存在误判.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">exists</span><span class="params">($string)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $pipe = <span class="keyword">$this</span>-&gt;Redis-&gt;multi();</span><br><span class="line">        $len = strlen($string);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;hashFunction <span class="keyword">as</span> $function) &#123;</span><br><span class="line">            $hash = <span class="keyword">$this</span>-&gt;Hash-&gt;$function($string, $len);</span><br><span class="line">            $pipe = $pipe-&gt;getBit(<span class="keyword">$this</span>-&gt;bucket, $hash);</span><br><span class="line">        &#125;</span><br><span class="line">        $res = $pipe-&gt;exec();</span><br><span class="line">        <span class="keyword">foreach</span> ($res <span class="keyword">as</span> $bit) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilteRepeatedComments</span> <span class="keyword">extends</span> <span class="title">BloomFilterRedis</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $bucket = <span class="string">'rptc'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> $hashFunction = <span class="keyword">array</span>(<span class="string">'BKDRHash'</span>, <span class="string">'SDBMHash'</span>, <span class="string">'JSHash'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>源码地址：<a href="https://gitee.com/pchangl/Bloom-Filter-Demo" target="_blank" rel="noopener">https://gitee.com/pchangl/Bloom-Filter-Demo</a></p>

  </article>
  <footer class="f-cf">
    
    
  </footer>
</section></div>
    <footer id="footer" class="f-cf">
  d.guangying@foxmail.com
  
    
      
        · <a href="https://github.com/pchangl" target="_blank" class="nav-icn">GitHub</a>
      
    
  
  <span class="copyright">All rights reserved @Clover Tuan</span>
</footer>
  </div>
</body>
</html>